/**
 * Report Generator - Creates markdown reports from processed data
 */

import fs from 'fs/promises';
import path from 'path';
import { config } from '../config.js';
import JSONReportGenerator from './json-report-generator.js';

export class ReportGenerator {
  constructor() {
    this.outputDir = config.reporting.outputDir;
    this.jsonReportGenerator = new JSONReportGenerator();
  }

  /**
   * Generate complete report from processed data
   */
  async generateReport(allPosts, date = new Date()) {
    try {
      console.log('📝 Generating report...');
      
      // Create output directory
      const dateStr = this.formatDate(date);
      const reportDir = path.join(this.outputDir, dateStr);
      await this.ensureDirectoryExists(reportDir);
      
      // Process data for report
      const processor = await import('./data-processor.js');
      const dataProcessor = new processor.DataProcessor();
      
      const sortedPosts = dataProcessor.sortByEngagement(allPosts);
      const categoryGroups = dataProcessor.groupByCategory(allPosts);
      const trendingThemes = dataProcessor.extractTrendingThemes(allPosts);
      const executiveSummary = dataProcessor.generateExecutiveSummary(allPosts, categoryGroups);
      
      // Generate report content
      const reportContent = this.buildReportContent({
        date: dateStr,
        posts: sortedPosts,
        categoryGroups,
        trendingThemes,
        executiveSummary
      });
      
      // Write report files
      const reportPath = path.join(reportDir, config.reporting.reportFileName);
      await fs.writeFile(reportPath, reportContent, 'utf8');
      
      // Generate JSON report with proper format
      const jsonResult = await this.jsonReportGenerator.generateJSONReport(allPosts, date);
      console.log(`💾 JSON report saved: ${jsonResult.jsonPath}`);
      
      console.log(`✅ Report generated: ${reportPath}`);
      console.log(`📊 Total posts analyzed: ${allPosts.length}`);
      
      return {
        reportPath,
        jsonPath: jsonResult.jsonPath,
        stats: {
          totalPosts: allPosts.length,
          categoriesAnalyzed: Object.keys(categoryGroups).length,
          topPost: sortedPosts[0]?.title || 'N/A',
          hasFullContent: jsonResult.stats.hasFullContent
        }
      };
    } catch (error) {
      console.error('❌ Failed to generate report:', error.message);
      throw error;
    }
  }

  /**
   * Build complete markdown report content
   */
  buildReportContent({ date, posts, categoryGroups, trendingThemes, executiveSummary }) {
    const sections = [];
    
    // Header
    sections.push(this.buildHeader(date));
    
    // Executive Summary
    if (config.reporting.includeExecutiveSummary) {
      sections.push(this.buildExecutiveSummary(executiveSummary));
    }
    
    // Top Posts
    sections.push(this.buildTopPostsSection(posts));
    
    // Category Breakdown
    if (config.reporting.includeCategoryBreakdown) {
      sections.push(this.buildCategoryBreakdown(categoryGroups));
    }
    
    // Trending Themes
    if (config.reporting.includeTrendingThemes && trendingThemes.length > 0) {
      sections.push(this.buildTrendingThemes(trendingThemes));
    }
    
    // Footer
    sections.push(this.buildFooter());
    
    return sections.join('\n\n');
  }

  /**
   * Build report header
   */
  buildHeader(date) {
    return `# IndieHackers Daily Report - ${date}

*Generated by IndieHackers Analytics Scraper*

---`;
  }

  /**
   * Build executive summary section
   */
  buildExecutiveSummary(summary) {
    return `## Executive Summary

- **Total posts analyzed:** ${summary.totalPosts}
- **Categories covered:** ${summary.categories}
- **Top engagement category:** ${summary.topCategory || 'N/A'}
- **Average engagement per post:** ${summary.avgEngagementPerPost}
- **Total community engagement:** ${summary.totalEngagement} interactions
- **Report generated:** ${this.formatDateTime(new Date(summary.scrapedAt))}`;
  }

  /**
   * Build top posts section
   */
  buildTopPostsSection(posts) {
    const topPosts = posts.slice(0, config.reporting.topPostsLimit);
    
    let content = `## Top Posts (Ranked by Engagement)\n\n`;
    
    topPosts.forEach((post, index) => {
      content += this.formatPost(post, index + 1);
      if (index < topPosts.length - 1) {
        content += '\n---\n\n';
      }
    });
    
    return content;
  }

  /**
   * Build category breakdown section
   */
  buildCategoryBreakdown(categoryGroups) {
    let content = `## Category Breakdown\n\n`;
    
    // Sort categories by total engagement
    const sortedCategories = Object.entries(categoryGroups).sort((a, b) => {
      const aTotal = a[1].posts.reduce((sum, post) => sum + post.engagementScore, 0);
      const bTotal = b[1].posts.reduce((sum, post) => sum + post.engagementScore, 0);
      return bTotal - aTotal;
    });
    
    sortedCategories.forEach(([key, group]) => {
      const { category, posts: categoryPosts } = group;
      const limitedPosts = categoryPosts.slice(0, config.reporting.postsPerCategoryLimit);
      
      content += `### ${category.name} (${categoryPosts.length} posts)\n\n`;
      
      limitedPosts.forEach((post, index) => {
        const commentCount = post.commentCount || post.comments?.length || post.engagement?.comments || 0;
        const upvotes = post.engagement?.upvotes || post.upvotes || 0;
        const author = post.author?.username || post.author || 'Unknown';
        const engagementText = `${commentCount} comments, ${upvotes} upvotes`;
        content += `${index + 1}. **[${post.title}](${post.url})**\n`;
        content += `   *By @${author} • ${engagementText} • Score: ${post.engagementScore}*\n\n`;
      });
      
      if (categoryPosts.length > limitedPosts.length) {
        content += `   *... and ${categoryPosts.length - limitedPosts.length} more posts*\n\n`;
      }
    });
    
    return content;
  }

  /**
   * Build trending themes section
   */
  buildTrendingThemes(themes) {
    let content = `## Trending Themes\n\n`;
    content += `*Based on keyword frequency analysis across all posts*\n\n`;
    
    themes.forEach((theme, index) => {
      content += `### ${index + 1}. ${theme.theme}\n`;
      content += `**Mentioned in ${theme.count} posts**\n\n`;
      
      if (theme.posts.length > 0) {
        content += `Related posts:\n`;
        theme.posts.slice(0, 3).forEach(post => {
          content += `- [${post.title}](${post.url}) (${post.engagement.comments} comments)\n`;
        });
        content += '\n';
      }
    });
    
    return content;
  }

  /**
   * Build report footer
   */
  buildFooter() {
    return `---

## About This Report

This report was automatically generated by the IndieHackers Analytics Scraper using Playwright web automation. The data includes posts from the following categories:

${Object.entries(config.categories).map(([key, cat]) => `- **${cat.name}**: ${cat.description}`).join('\n')}

**Engagement Scoring:**
- Comments: ${config.scoring.weights.comments * 100}% weight
- Upvotes: ${config.scoring.weights.upvotes * 100}% weight  
- Recency: ${config.scoring.weights.recency * 100}% weight

*Generated on ${this.formatDateTime(new Date())}*`;
  }

  /**
   * Format individual post for display
   */
  formatPost(post, rank) {
    // Handle both old and new post formats
    const commentCount = post.commentCount || post.comments?.length || post.engagement?.comments || 0;
    const upvotes = post.engagement?.upvotes || post.upvotes || 0;
    const author = post.author?.username || post.author || 'Unknown';
    
    const engagementText = `${commentCount} comments, ${upvotes} upvotes`;
    const timestamp = post.timestamp ? this.formatTimestamp(post.timestamp) : 'Unknown time';
    
    let content = `### ${rank}. ${post.title}

**Author:** @${author}  
**Category:** ${post.category.name}  
**Engagement:** ${engagementText}  
**Engagement Score:** ${post.engagementScore}  
**Posted:** ${timestamp}  `;
    
    // Add tags if available
    if (post.tags && post.tags.length > 0) {
      content += `\n**Tags:** ${post.tags.join(', ')}  `;
    }
    
    // Add views if available
    if (post.views && post.views > 0) {
      content += `\n**Views:** ${post.views}  `;
    }
    
    content += `\n**URL:** ${post.url}\n\n`;
    
    // Add full content if available
    if (post.fullContent && post.fullContent.length > 100) {
      content += `**Content:**\n\n`;
      // Truncate very long content for report
      const fullContent = post.fullContent.length > 800 
        ? post.fullContent.substring(0, 800) + '...'
        : post.fullContent;
      content += `> ${fullContent.replace(/\n/g, '\n> ')}\n\n`;
    } else if (post.content?.summary) {
      content += `**Summary:** ${post.content.summary}\n\n`;
    }
    
    // Add top comments if available
    if (post.comments && Array.isArray(post.comments) && post.comments.length > 0) {
      content += `**Comments (${post.comments.length} total):**\n\n`;
      const topComments = post.comments.slice(0, 3);
      topComments.forEach((comment, idx) => {
        content += `${idx + 1}. **${comment.author}**`;
        if (comment.upvotes > 0) {
          content += ` (${comment.upvotes} upvotes)`;
        }
        content += `:\n   > ${comment.text?.substring(0, 200)}${comment.text?.length > 200 ? '...' : ''}\n\n`;
      });
      
      if (post.comments.length > 3) {
        content += `   *... and ${post.comments.length - 3} more comments*\n`;
      }
    }
    
    return content;
  }

  /**
   * Utility methods for formatting
   */
  formatDate(date) {
    return date.toISOString().split('T')[0]; // YYYY-MM-DD
  }

  formatDateTime(date) {
    return date.toISOString().replace('T', ' ').replace(/\.\d{3}Z$/, ' UTC');
  }

  formatTimestamp(timestamp) {
    if (!timestamp) return 'Unknown';
    
    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now - date;
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffHours / 24);
    
    if (diffHours < 1) {
      const diffMins = Math.floor(diffMs / (1000 * 60));
      return `${diffMins}m ago`;
    } else if (diffHours < 24) {
      return `${diffHours}h ago`;
    } else if (diffDays < 7) {
      return `${diffDays}d ago`;
    } else {
      return date.toLocaleDateString();
    }
  }

  /**
   * Ensure directory exists
   */
  async ensureDirectoryExists(dirPath) {
    try {
      await fs.access(dirPath);
    } catch {
      await fs.mkdir(dirPath, { recursive: true });
      console.log(`📁 Created directory: ${dirPath}`);
    }
  }

  /**
   * Generate JSON summary for API consumption
   */
  async generateJsonSummary(posts, outputPath) {
    const summary = {
      metadata: {
        generatedAt: new Date().toISOString(),
        version: '1.0',
        totalPosts: posts.length
      },
      topPosts: posts.slice(0, 5).map(post => ({
        title: post.title,
        author: post.author.username,
        url: post.url,
        engagementScore: post.engagementScore,
        category: post.category.name
      })),
      categoryStats: this.generateCategoryStats(posts),
      engagementStats: {
        totalComments: posts.reduce((sum, post) => sum + post.engagement.comments, 0),
        totalUpvotes: posts.reduce((sum, post) => sum + post.engagement.upvotes, 0),
        avgEngagement: posts.reduce((sum, post) => sum + post.engagementScore, 0) / posts.length
      }
    };

    await fs.writeFile(outputPath, JSON.stringify(summary, null, 2), 'utf8');
    console.log(`📊 JSON summary saved: ${outputPath}`);
    
    return summary;
  }

  /**
   * Generate category statistics
   */
  generateCategoryStats(posts) {
    const stats = {};
    
    posts.forEach(post => {
      const category = post.category.key;
      if (!stats[category]) {
        stats[category] = {
          name: post.category.name,
          count: 0,
          totalEngagement: 0,
          avgEngagement: 0
        };
      }
      
      stats[category].count++;
      stats[category].totalEngagement += post.engagementScore;
    });
    
    // Calculate averages
    Object.values(stats).forEach(stat => {
      stat.avgEngagement = Math.round((stat.totalEngagement / stat.count) * 100) / 100;
    });
    
    return stats;
  }
}

export default ReportGenerator;